import { isBrowser, getRegisteredStyles, insertStyles } from '@emotion/utils';
import { createContext, createElement, Component, Fragment } from 'react';
import createCache from '@emotion/cache';
import { serializeStyles } from '@emotion/serialize';
import { StyleSheet } from '@emotion/sheet';
import css from '@emotion/css';
export { default as css } from '@emotion/css';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var CSSContext = createContext(isBrowser ? createCache() : null);
var Provider = CSSContext.Provider;

var withCSSContext = function withCSSContext(func) {
  return function (props) {
    return createElement(CSSContext.Consumer, null, function ( // $FlowFixMe we know it won't be null
    context) {
      return func(props, context);
    });
  };
};

var consume = function consume(func) {
  return createElement(CSSContext.Consumer, null, // $FlowFixMe we know it won't be null
  func);
};

if (!isBrowser) {
  var BasicProvider =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(BasicProvider, _React$Component);

    function BasicProvider(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.state = {
        value: createCache()
      };
      return _this;
    }

    var _proto = BasicProvider.prototype;

    _proto.render = function render() {
      return createElement(CSSContext.Provider, this.state, this.props.children(this.state.value));
    };

    return BasicProvider;
  }(Component);

  withCSSContext = function withCSSContext(func) {
    return function (props) {
      return createElement(CSSContext.Consumer, null, function (context) {
        if (context === null) {
          return createElement(BasicProvider, null, function (newContext) {
            return func(props, newContext);
          });
        } else {
          return func(props, context);
        }
      });
    };
  };

  consume = function consume(func) {
    return createElement(CSSContext.Consumer, null, function (context) {
      if (context === null) {
        return createElement(BasicProvider, null, function (newContext) {
          return func(newContext);
        });
      } else {
        return func(context);
      }
    });
  };
}

var jsx = function jsx(type, props) {
  var _arguments = arguments;

  if (props == null || props.css == null) {
    // $FlowFixMe
    return createElement.apply(undefined, arguments);
  }

  if (typeof props.css === 'string' && process.env.NODE_ENV !== 'production' && // check if there is a css declaration
  props.css.indexOf(':') !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/css' like this: css`" + props.css + "`");
  }

  return consume(function (context) {
    var registeredStyles = [];
    var className = '';

    if (props.className !== undefined) {
      className = getRegisteredStyles(context.registered, registeredStyles, props.className);
    }

    registeredStyles.push(typeof props.css === 'function' ? props.css(context.theme) : props.css);
    var serialized = serializeStyles(context.registered, registeredStyles);
    var rules = insertStyles(context, serialized, typeof type === 'string');
    className += context.key + "-" + serialized.name;
    var newProps = {};

    for (var key in props) {
      if (Object.prototype.hasOwnProperty.call(props, key) && key !== 'css') {
        newProps[key] = props[key];
      }
    }

    newProps.className = className;
    var argsLength = _arguments.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = type;
    createElementArgArray[1] = newProps;

    for (var i = 2; i < argsLength; i++) {
      createElementArgArray[i] = _arguments[i];
    } // $FlowFixMe


    var ele = createElement.apply(undefined, createElementArgArray);

    if (!isBrowser && rules !== undefined) {
      var _ref;

      return createElement(Fragment, null, createElement("style", (_ref = {}, _ref["data-emotion-" + context.key] = serialized.name, _ref.dangerouslySetInnerHTML = {
        __html: rules
      }, _ref.nonce = context.sheet.nonce, _ref)), ele);
    }

    return ele;
  });
};

var Global =
/* #__PURE__ */
withCSSContext(function (props, context) {
  return createElement(InnerGlobal, {
    styles: props.styles,
    context: context
  });
});

// maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag
var InnerGlobal =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(InnerGlobal, _React$Component);

  function InnerGlobal(props) {
    return _React$Component.call(this, props) || this;
  }

  var _proto = InnerGlobal.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStyles();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.updateStyles();
  };

  _proto.updateStyles = function updateStyles() {
    var serialized = serializeStyles(this.props.context.registered, [this.props.styles]);

    if (serialized.name === this.styleName) {
      return;
    }

    this.styleName = serialized.name;

    if (!this.sheet) {
      this.sheet = new StyleSheet({
        key: this.props.context.key + "-global",
        nonce: this.props.context.sheet.nonce,
        container: this.props.context.sheet.container
      }); // $FlowFixMe

      var node = document.querySelector("style[data-emotion-" + this.props.context.key + "=\"" + serialized.name + "\"]");

      if (node !== null) {
        this.sheet.tags.push(node);
      } // $FlowFixMe


      if (this.props.context.sheet.tags.length) {
        this.sheet.before = this.props.context.sheet.tags[0];
      }
    }

    var rules = this.props.context.stylis("", serialized.styles);

    if (this.sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      this.sheet.before = this.sheet.tags[0].nextElementSibling;
      this.sheet.flush();
    }

    rules.forEach(this.sheet.insert, this.sheet);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.sheet.flush();
  };

  _proto.render = function render() {
    if (!isBrowser) {
      var _ref;

      var serialized = serializeStyles(this.props.context.registered, [this.props.styles]);
      var rules = this.props.context.stylis("", serialized.styles);
      return createElement("style", (_ref = {}, _ref["data-emotion-" + this.props.context.key] = serialized.name, _ref.dangerouslySetInnerHTML = {
        __html: rules.join('')
      }, _ref.nonce = this.props.context.sheet.nonce, _ref));
    }

    return null;
  };

  return InnerGlobal;
}(Component);

var keyframes = function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

export { withCSSContext, Provider, jsx, Global, keyframes };
